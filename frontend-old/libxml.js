/**
 * libxml-wasm 1.1.0
 * https://github.com/KSFE-D/libxml-wasm
 *
 * This is the full source code for the library, allowing it to be run locally
 * without relying on an external CDN.
 */
var libxml;(()=>{"use strict";var e={d:(t,r)=>{for(var a in r)e.o(r,a)&&!e.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:r[a]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{default:()=>u});const r={};var a,n,i;function o(e){return r[e]}function s(e,t){r[e]=t,postMessage({type:"symbols",body:e})}const l={loaded:!1,load:async()=>{const e=new Promise((e=>{a=e}));return l.loaded||(n=new Worker(new URL("libxml-wasm-5a9e339160533036.worker.js",import.meta.url)),i={},n.addEventListener("message",(e=>{const t=e.data.type,r=e.data.body,o=e.data.id;switch(t){case"symbols":a(void 0);break;case"call":{const e=i[o];"function"==typeof e&&e(r)}break;case"stream":{const e=i[o];"function"==typeof e&&e(r,e)}}})),n.postMessage({type:"init"})),await e,l.loaded=!0,Promise.resolve(l)},parseXml:e=>("string"!=typeof e&&console.error("source must be a string"),new Promise((t=>{const r=Math.random().toString(36);i[r]=e=>t(new d(e)),n.postMessage({type:"parseXml",body:e,id:r})}))),parseSchema:e=>("string"!=typeof e&&console.error("source must be a string"),new Promise((t=>{const r=Math.random().toString(36);i[r]=e=>t(new c(e)),n.postMessage({type:"parseSchema",body:e,id:r})}))),streamXml:e=>(console.warn("stream parser is experimental"),new Promise((t=>{const r=Math.random().toString(36),a=new ReadableStream({start:a=>{const i=e=>{n.postMessage({type:"stream",body:e,id:r}),a.enqueue(e)},s=t=>{i(t.value),t.done||e.read().then(s)};e.read().then(s),i[r]=a.close()}}),s={};s.on=o("stream"),i[r]=(e,r)=>{const n=e=>("function"==typeof s[e]&&s[e](...r),e in s||console.warn(`no handler for event "${e}"`));switch(e.type){case"warning":n("warning",e.body);break;case"error":n("error",e.body);break;case"startElement":n("startElement",e.body);break;case"endElement":n("endElement",e.body);break;case"characters":n("characters",e.body);break;case"endDocument":n("endDocument"),r()}},t(a)})))};class m{constructor(e){s(this,e),this.docPtr=e.docPtr,this.validate=e.validate||void 0,this.errors=e.errors||void 0}root(){return new Promise((e=>{const t=Math.random().toString(36);i[t]=t=>e(new p(t)),n.postMessage({type:"root",body:{docPtr:this.docPtr},id:t})}))}errors(){return this.errors}validate(e){return new Promise((t=>{const r=Math.random().toString(36);i[r]=e=>{this.errors=e,t(e)},n.postMessage({type:"validate",body:{docPtr:this.docPtr,schemaPtr:o(e).schemaPtr},id:r})}))}}class d extends m{constructor(e){super(e)}}class c{constructor(e){s(this,e),this.schemaPtr=e.schemaPtr,this.validate=e.validate||void 0}validate(e){return o(this).validate(e)}}class p{constructor(e){s(this,e),this.name=e.name,this.children=e.children||void 0,this.attributes=e.attributes||void 0,this.docPtr=e.docPtr,this.nodePtr=e.nodePtr,this.type=e.type}name(){return this.name}children(){const e=o(this).children.map((e=>new p(e)));return e}attributes(){return o(this).attributes}text(){return new Promise((e=>{const t=Math.random().toString(36);i[t]=t=>e(t),n.postMessage({type:"text",body:{docPtr:this.docPtr,nodePtr:this.nodePtr},id:t})}))}}const u=l})();